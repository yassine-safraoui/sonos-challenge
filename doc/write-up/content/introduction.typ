= Introduction
The goal of this challenge is to build two Rust programs: a server that sends audio data over TCP, and a client that receives that audio and can “use” the samples (e.g. write them to disk or play them). The context given is a wake‑word / ASR system that needs real‑time audio streams, but the challenge itself is deliberately narrower: I am not implementing wake‑word detection or speech recognition, only the reliable, real‑time delivery of audio samples from server to client.

The description also mentions “distributing the acquisition and processing of such audio streams” across clients. I interpret that as a future, larger system where multiple clients each process different portions of the audio stream, rather than all clients redundantly doing the same work. That coordination layer (deciding which client processes which segment, aggregating results, etc.) is outside the scope of what I implemented here. My focus is on building a solid base: one server streaming audio, and one or more clients able to consume that stream.

A key aspect of this work is that it focuses on *streaming* rather than on a simple bulk data transfer. By “stream”, I mean a time‑ordered flow of audio samples delivered at (approximately) the rate they would be produced or played, not just a file being pushed as fast as the network allows. Even though the current source is a WAV file, the server sends PCM samples in paced chunks that follow the audio’s sample rate, so the client receives data in a way that closely matches real‑time audio input rather than a raw file download.